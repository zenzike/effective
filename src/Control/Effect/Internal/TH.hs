{-|
Module      : Control.Effect.Internal.TH
Description : Template Haskell helpers to generate Alg/Scp effect boilerplate
License     : BSD-3-Clause
Maintainer  : Nicolas Wu, Zhixuan Yang
Stability   : experimental

This module provides Template Haskell splices that generate common boilerplate
for algebraic effects and scoped effects.

There are three families of generators:

  * Generic operations, i.e. operations of the form
    @
    A_1 -> ... A_n -> Prog sig B
    @
    are generated using 'makeGen' or 'makeGenFrom'.

  * Algebraic operations, i.e. operations of the form
    @
    A_1 -> ... A_n -> Prog sig x -> ... -> Prog sig x -> Prog sig x
    @
    satisfying the algebraicity law, are generated using
    'makeAlg' or 'makeAlgFrom'.

  * Scoped operations, i.e. operations of the form
    @
    A_1 -> ... A_n -> Prog sig x -> ... -> Prog sig x -> Prog sig x
    @
    (without the requirement of the algebraicity law), are generated using
    'makeScp' or 'makeScpFrom'.

Split variants let you generate only the __type synonym__, only the
__pattern synonym__, or only the __smart constructor(s)__.

=== Examples

An example of generic operations is @put :: Member (Put s) sig => s -> Prog sig ()@.
It (together with its signature functors, pattern synonyms, ...) can be generated by
putting the following line at the top level of a @.hs@ file:
@
$(makeGen [e| put :: forall s. s -> () |])
@
Similarly, the operation @get :: Member (Get s) sig => Prog sig s@ can be generated by
@
$(makeGen [e| get :: forall s. s |])
@
(The explicit @forall s@ quantification in these two lines is currently required.)

An example of algebraic operations is probabilistic choice @flip :: Member Flip sig => Float -> Prog sig x -> Prog sig x -> Prog sig x@,
and it can be generated by
@
$(makeAlg [e| flip :: Float -> 2 |])
@
The operations generated by @makeAlg@ always have paramters before the @Prog@ arguments.
Some flexibility is allowed by using @makeAlgFrom@. For example,
@
data Flip_ k = Flip_ k Float k
$(makeAlgFrom ''Flip_)
@
generates:
@
flip :: Member Flip sig => Prog sig x -> Float -> Prog sig x -> Prog sig x
@

An example of scoped operations is @catch :: Member Catch sig => Prog sig x -> Prog sig x -> Prog sig x@, which
can be generated by
@
$(makeScp [e| catch :: 2 |])
@
-}
{-# LANGUAGE CPP, LambdaCase, TemplateHaskell, RecordWildCards #-}
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
{-# LANGUAGE RequiredTypeArguments #-}
#endif

module Control.Effect.Internal.TH (
    makeGen, makeGenFrom, makeGenTypeFrom, makeGenPatternFrom, makeGenSmartFrom,
    makeAlg, makeAlgFrom, makeAlgTypeFrom, makeAlgPatternFrom, makeAlgSmartFrom,
    makeScp, makeScpFrom, makeScpTypeFrom, makeScpPatternFrom, makeScpSmartFrom,
  ) where

import Control.Effect.Internal.Prog
import Control.Effect.Internal.Effs
import Control.Effect.Family.Algebraic
import Control.Effect.Family.Scoped
import Control.Effect.WithName
import Data.Proxy
import Data.Char
import Data.List
import Control.Monad
import Language.Haskell.TH

-- This code is best tested by looking at the generated output in GHCi,
-- by using:
--
-- ghci> :set -XTemplateHaskell -XPatternSynonyms -XViewPatterns
-- ghci> :set -XDataKinds -XGADTs -XRankNTypes -XPolyKinds
-- ghci> :set -ddump-splices
-- ghci> :l src/Control/Effect/Internal/TH.hs
--
-- Then, when files that use `$(makeAlg ...)` are used, GHCi will
-- print the spliced code for inspection.

--------------------------------------------------------------------------------
-- Alg generators
--------------------------------------------------------------------------------

data FunPieces = FunPieces
  { pPragma :: Dec
  , pSig    :: Dec
  , pFun    :: Dec
  }

data AlgPieces = AlgPieces
  { apTySyn       :: Dec
  , apPat         :: Dec
  , apSmart       :: FunPieces
  , apProxySmart  :: FunPieces
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
  , apNamedSmart  :: FunPieces
#endif
  }

class ToDecs a where
  toDecs :: a -> [Dec]

instance ToDecs Dec where
  toDecs d = [d]

instance ToDecs FunPieces where
  toDecs (FunPieces {..}) = [pPragma, pSig, pFun]

instance ToDecs AlgPieces where
  toDecs (AlgPieces {..}) = [apTySyn] ++ [apPat] ++ toDecs apSmart ++ toDecs apProxySmart
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
    ++ toDecs apNamedSmart
#endif

makeGenPieces :: Name -> Q AlgPieces
makeGenPieces baseName = do
  info <- reify baseName
  case info of
    TyConI d -> makeGenPiecesFromDec baseName d
    _ -> fail "makeGen: expected the name of a data/newtype with a single constructor"

makeGenPiecesFromDec :: Name -> Dec -> Q AlgPieces
makeGenPiecesFromDec baseName dec = do
  (tvbs, conName, argTys) <- case dec of
    (DataD    [] _ tvbs _ [con] _) -> pure (tvbs, conNameOf con, conArgTys con)
    (NewtypeD [] _ tvbs _  con  _) -> pure (tvbs, conNameOf con, conArgTys con)
    _ -> fail "makeGen: expected data/newtype with a single constructor (without any constraints)"
  let tvNames = map tvbName tvbs
  when (null tvNames) $ fail "makeGen: the base functor must be at least unary (… k)"
  let (paramNames, kName) = (init tvNames, last tvNames)

  -- Zhixuan: I don't know why we need to do swap the type parameters for fresh names.
  freshParams <- mapM (newName . nameBase) paramNames
  let freshK = mkName (nameBase kName)
      substEnv = zip (paramNames ++ [kName]) (map VarT (freshParams ++ [freshK]))

  when (null argTys) $ fail "makeGen: constructor must have at least a continuation field"
  let (prefixTys, contTy) = (init argTys, last argTys)

  (retTy, contExpr) <- case stripT contTy of
    VarT v | eqNameBase v kName -> pure (TupleT 0, ConE '())
    t | Just (r, VarT v) <- viewArrow t, eqNameBase v kName -> pure (r, VarE 'id)
    _ -> fail "makeGen: unsupported continuation shape; expected `k` or `(r -> k)`"

  let retTy'     = substT substEnv retTy
      prefixTys' = map (substT substEnv) prefixTys

  let baseStr = nameBase baseName
      effStr  = dropTrailingUnderscore baseStr
      effName = mkName effStr
      funName = mkName (lowerHead effStr)
      proxyFunName = mkName (lowerHead effStr ++ "P")
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedFunName = mkName (lowerHead effStr ++ "N")
#endif

  let effTySyn :: Dec
      effTySyn = TySynD effName (map plainTVCompat freshParams)
                   (AppT (ConT ''Alg)
                     (applyType (ConT baseName) (map VarT freshParams)))

  sigName  <- newName "sig"
  nameName <- newName "name"
  let effTy   = applyType (ConT effName) (map VarT freshParams)
      memberC = AppT (AppT (ConT ''Member) effTy) (VarT sigName)
      progRes = AppT (AppT (ConT ''Prog) (VarT sigName)) retTy'
      smartTy = ForallT (map plainTVForall (freshParams ++ [sigName])) [memberC]
                        (funType prefixTys' progRes)
      namedEffTy   = AppT (AppT (ConT ''WithName) (VarT nameName)) effTy
      namedMemberC = AppT (AppT (ConT ''Member) namedEffTy) (VarT sigName)
      proxyTy      = AppT (ConT ''Proxy) (VarT nameName)
      proxySmartTy = ForallT (map plainTVForall ([nameName] ++ freshParams ++ [sigName])) [namedMemberC]
                        (funType (proxyTy : prefixTys') progRes)
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartTy = ForallVisT [plainTV nameName]
                       (ForallT (map plainTVForall (freshParams ++ [sigName])) [namedMemberC]
                        (funType prefixTys' progRes))
#endif

  xVars <- mapM (\i -> newName ("x" ++ show i)) [1 .. length prefixTys']
  kVar  <- newName "k"

  let patArgs = PrefixPatSyn (xVars ++ [kVar])
      scrut   = VarE 'prj
      inner   = conPCompat 'Just [conPCompat 'Alg [conPCompat conName (map VarP xVars ++ [VarP kVar])]]
      pat     = ViewP scrut inner
      builder = NormalB (AppE (VarE 'inj)
                        (AppE (ConE 'Alg)
                          (applyExp (ConE conName) (map VarE xVars ++ [VarE kVar]))))
      patDir  = ExplBidir [Clause (map VarP (xVars ++ [kVar])) builder []]
      patDecl = PatSynD (mkName effStr) patArgs patDir pat

  argNames <- mapM (\i -> newName ("a" ++ show i)) [1 .. length prefixTys']
  nName <- newName "n"
  let smartLhs = Clause (map VarP argNames)
                        (NormalB (VarE 'call `AppE`
                                   (ConE 'Alg `AppE`
                                      applyExp (ConE conName)
                                        (map VarE argNames ++ [contExpr]))))
                        []
      smartSig = SigD funName smartTy
      smartFun = FunD funName [smartLhs]
      pragma   = PragmaD (InlineP funName Inline FunLike AllPhases)

      proxySmartLhs = Clause (map VarP (nName : argNames))
                       (NormalB (AppE (AppE (VarE 'callP) (VarE nName))
                                      (ConE 'Alg `AppE` applyExp (ConE conName)
                                        (map VarE argNames ++ [contExpr]))))
                       []
      proxySmartSig = SigD proxyFunName proxySmartTy
      proxySmartFun = FunD proxyFunName [proxySmartLhs]
      proxyPragma   = PragmaD (InlineP proxyFunName Inline FunLike AllPhases)

#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartLhs = Clause (map VarP (nName : argNames))
                       (NormalB (AppE (AppE (VarE 'callN) (VarE nName))
                                      (ConE 'Alg `AppE` applyExp (ConE conName)
                                        (map VarE argNames ++ [contExpr]))))
                       []
      namedSmartSig = SigD namedFunName namedSmartTy
      namedSmartFun = FunD namedFunName [namedSmartLhs]
      namedPragma   = PragmaD (InlineP namedFunName Inline FunLike AllPhases)
#endif


  pure AlgPieces{ apTySyn      = effTySyn, apPat = patDecl
                , apSmart      = FunPieces pragma smartSig smartFun
                , apProxySmart = FunPieces proxyPragma proxySmartSig proxySmartFun
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
                , apNamedSmart = FunPieces namedPragma namedSmartSig namedSmartFun
#endif
                }

-- | Generate the full bundle of a generic opration from a base signature functor @T_@.
--
-- Input must be a single-constructor @data@/@newtype@ whose /last field/
-- is the continuation @k@ (either @k@ or @(r -> k)@).
--
-- Produces:
--
--   * @type T params = Alg (T_ params)@
--   * a bidirectional @pattern T ...@ matching/injecting @inj (Alg (Con ...))@
--   * a smart constructor (lower-cased name):
--       - if the continuation is @k@, returns @Prog sig ()@ and passes @()@
--       - if the continuation is @(r -> k)@, returns @Prog sig r@ and uses @id@
--   * a smart constructor for making _named_ operation calls (c.f. `Control.Effect.WithName`),
--     where the name is passed as a proxy argument
--   * if the extension @RequiredTypeArguments@ is available (GHC >= 9.10.1), a smart constructor
--     for named operation calls with names passed as explicit type arguments
--
-- Example:
-- @
-- data Put_ s k = Put_ s k
--   deriving Functor
-- makeAlg (''Put_ s)
-- @
-- This will generate:
-- @
-- type Put s = Alg (Put_ s)
--
-- pattern Put :: Member (Put s) effs => s -> k -> Effs effs m k
-- pattern Put s k <- (prj -> Just (Alg (Put_ s k)))
--   where Put s k = inj (Alg (Put_ s k))
--
-- {-# INLINE put #-}
-- put :: Member (Put s) sig => s -> Prog sig ()
-- put s = call (Alg (Put_ s ()))
--
-- {-# INLINE putP #-}
-- putP :: Member (WithName n (Put s)) sig => Proxy n -> s -> Prog sig ()
-- putP p s = callP p (Alg (Put_ s ()))
--
-- -- If GHC >= 9.10.1, we have also
-- {-# INLINE putN #-}
-- putN :: forall n -> Member (WithName n (Put s)) sig => s -> Prog sig ()
-- putN p s = callN p (Alg (Put_ s ()))
-- @
makeGenFrom :: Name -> Q [Dec]
makeGenFrom baseName = fmap toDecs $ makeGenPieces baseName

-- | Generate only the /type synonym/ for a generic operation.
makeGenTypeFrom :: Name -> Q [Dec]
makeGenTypeFrom baseName = do
  AlgPieces{..} <- makeGenPieces baseName
  pure [apTySyn]

-- | Generate only the /pattern synonym/ (bidirectional) for a generic operation.
makeGenPatternFrom :: Name -> Q [Dec]
makeGenPatternFrom baseName = do
  AlgPieces{..} <- makeGenPieces baseName
  pure [apPat]

-- | Generate only the smart constructors (with @INLINE@ and explicit type) for a generic operation.
makeGenSmartFrom :: Name -> Q [Dec]
makeGenSmartFrom baseName = do
  AlgPieces{..} <- makeGenPieces baseName
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
  pure (toDecs apSmart ++ toDecs apNamedSmart ++ toDecs apProxySmart)
#else
  pure (toDecs apSmart ++ toDecs apProxySmart)
#endif

-- | Generate the full bundle of a generic operation from a type signature.
-- For example, the following
-- @
-- $(makeGen [e| put :: forall s. s -> () |])
-- @
-- generates all the boilerplate for the usual @put@ operation.
--
-- Note that the arugment should be the signature of the operation _as if it
-- were a pure operation_.  There is no need to include @Member@ constraints or
-- the monad @Prog@ in the signature. The argument isn't really the type of the
-- generated smart constructor. It is just for giving all the needed information
-- of an operation. The generated smart constructor of course will have the
-- @Member@ constraint and the @Prog@ monad, such as
-- @
-- put :: Member Put sig => s -> Prog sig ()
-- @
--
-- Note also that if the operation has type parameters (like the @put@ example above),
-- the given signature should have an explicit forall quantifier of all the type
-- variables (like @s@ above).
--
-- The following are some more examples:
--  $(makeAlg' [e| get :: forall s. s |])
--  $(makeAlg' [e| flip :: Bool |])
--  $(makeAlg' [e| op1 :: forall s. s -> (s,s) -> Int |])
--  $(makeAlg' [e| op2 :: forall a b. (a,b) -> b |])
--
-- Operations of the form @Prog a -> Prog a -> Prog a@, such as @choose@, should use
-- `makeAlg` instead.

makeGen :: Q Exp -> Q [Dec]
makeGen sigQ =
  do sig <- sigQ
     (opName, ty) <- case sig of
       SigE (UnboundVarE opName) ty -> pure (opName, ty)
       SigE (VarE        opName) ty -> pure (opName, ty)
       _ -> fail "the argument should be of the form \"op :: ...\" for some name op"
     let (tvBndrs, ctx, ty') =
            case ty of
              ForallT tvs ctx ty' -> (tvs, ctx, ty');
              _ -> ([], [], ty)
     when (not (null ctx)) $
       fail "constraints on type arguments are not yet supported"
     kName <- newName "k"
     let (argTys, resTy) = splitArrs ty'
         sigName = mkName (upperHead (nameBase opName ++ "_"))
         conName = sigName
         tyParams = fmap (plainTVCompat . tyVarName) tvBndrs ++ [plainTVCompat kName]
         mkNormalField ty = (Bang NoSourceUnpackedness NoSourceStrictness, ty)
         paramFields = map mkNormalField argTys
         contField = mkNormalField $
           if resTy == TupleT 0
             then VarT kName
             else AppT (AppT ArrowT resTy) (VarT kName)
         d = DataD [] sigName tyParams Nothing
               [NormalC conName (paramFields ++ [contField])]
               [DerivClause Nothing [ConT ''Functor]]
     pieces <- makeGenPiecesFromDec sigName d
     pure (d : toDecs pieces)


-- | Generate the full bundle of an algebraic operation from a \'type signature\'.
-- For example, the following
-- @
-- $(makeAlg [e| choose :: 2 |])
-- @
-- generates all the boilerplate for an algebraic operation
-- @
-- choose :: Member Choose sig => Float -> Prog sig x -> Prog sig x -> Prog sig x
-- @
-- Parameters to the operation are allowed. For example, @$(makeAlg [e| flip :: Float -> 2 |])@
-- generates:
-- @
-- flip :: Member Flip sig => Float -> Prog sig x -> Prog sig x -> Prog sig x
-- @
-- If the parameter types have free type variables, they must be explicitly quantified,
-- like @$(makeAlg [e| flip :: forall s. s -> 2 |])@.
--
-- Operations of the form @A -> Prog sig B@, such as @put@, should use `makeGen` instead.

makeAlg :: Q Exp -> Q [Dec]
makeAlg sigQ = do
  (sigName, d) <- makeAlgOrScpSigFunctor sigQ
  pieces <- makeAlgPiecesFromDec sigName d
  pure (d : toDecs pieces)

makeAlgOrScpSigFunctor :: Q Exp -> Q (Name, Dec)
makeAlgOrScpSigFunctor sigQ = do
  sig <- sigQ
  (opName, ty) <- case sig of
    SigE (UnboundVarE opName) ty -> pure (opName, ty)
    SigE (VarE        opName) ty -> pure (opName, ty)
    _ -> fail "makeAlgOrScpSigFunctor: the argument should be of the form \"op :: ...\" for some name op"
  let (tvBndrs, ctx, ty') =
         case ty of
           ForallT tvs ctx ty' -> (tvs, ctx, ty');
           _ -> ([], [], ty)
  when (not (null ctx)) $
    fail "makeAlgOrScpSigFunctor: constraints on type arguments are not yet supported"
  kName <- newName "k"
  let (argTys, resTy) = splitArrs ty'
  arity <-
    case resTy of
      LitT (NumTyLit n) -> pure (fromIntegral n)
      _ -> fail "makeAlgOrScpSigFunctor: the last type in the given signature should just be a number literal indicating the arity, like \"op :: ... -> 2\""
  let sigName = mkName (upperHead (nameBase opName ++ "_"))
      conName = sigName
      tyParams = fmap (plainTVCompat . tyVarName) tvBndrs ++ [plainTVCompat kName]
      mkNormalField ty = (Bang NoSourceUnpackedness NoSourceStrictness, ty)
      paramFields = map mkNormalField argTys
      contFields = replicate arity (mkNormalField (VarT kName))
      d = DataD [] sigName tyParams Nothing
            [NormalC conName (paramFields ++ contFields)]
            [DerivClause Nothing [ConT ''Functor]]
  return (sigName, d)

-- | Generate the full bundle of an algebraic operation from a base signature functor.
-- The argument to this function should be the name of a datatype/newtype with at
-- least one type variables, like @data T_ ... k = T_ ... deriving Functor@, and it
-- should have exactly one constructor, whose fields are either @k@ or a type not
-- containing @k@ at all.
--
-- For example, if given the following datatype
-- @
-- data Flip_ k = Flip_ k Float k deriving Functor
-- @
-- @$(makeAlgFrom ''Flip_)@ generates the operation:
-- @
-- flip :: Member Flip sigs => a -> Float -> a -> Effs sigs f a
-- @
-- As demonstrated in this example, compared to `makeAlg`, this function has
-- the flexibility that the order of the parameter types (like the @Float@) and
-- the @Prog@ arguments is flexibile.

makeAlgFrom :: Name -> Q [Dec]
makeAlgFrom baseName = fmap toDecs $ makeAlgPieces baseName

makeAlgPieces :: Name -> Q AlgPieces
makeAlgPieces baseName = do
  info <- reify baseName
  case info of
    TyConI d -> makeAlgPiecesFromDec baseName d
    _ -> fail "makeAlg: expected the name of a data/newtype with a single constructor"

makeAlgPiecesFromDec :: Name -> Dec -> Q AlgPieces
makeAlgPiecesFromDec baseName dec = do
  (tvbs, con) <- case dec of
    (DataD    [] _ tvbs _ [con] _) -> pure (tvbs, con)
    (NewtypeD [] _ tvbs _  con  _) -> pure (tvbs, con)
    _ -> fail "makeScp: expected data/newtype with a single constructor (without any constraints)"
  case con of
    GadtC _ _ _    -> fail "makeScp: GADT constructors not supported"
    RecGadtC _ _ _ -> fail "makeScp: GADT constructors not supported"
    _ -> pure ()

  when (null tvbs) $ fail "makeAlg: the base functor must be at least unary (… k)"

  let conName   = conNameOf con
      conFields = conArgTys con

      allTvNames = map tvbName tvbs
      (tvNames, kName) = (init allTvNames, last allTvNames)
      appCon :: [Name] -> Exp
      appCon = foldl (\e n -> AppE e (VarE n)) (ConE conName)
      baseStr = nameBase baseName

  when (not (endWithUnderscore baseStr)) $
    fail "makeAlg: expected the given datatype to have a name ending with an underscore '_'"

  let effStr  = dropTrailingUnderscore baseStr
      effName = mkName effStr
      patName = effName
      smartName = mkName (lowerHead effStr)
      proxySmartName = mkName (lowerHead effStr ++ "P")
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartName = mkName (lowerHead effStr ++ "N")
#endif

  -- Type synonym for the operation
  let effTySyn :: Dec
      effTySyn = TySynD effName (map plainTVCompat tvNames)
                   (AppT (ConT ''Alg)
                     (applyType (ConT baseName) (map VarT tvNames)))

  sigName   <- newName "sig"
  nameName  <- newName "name"
  retTyName <- newName "x"

  -- Type signatures for the smart constructors
  let effTy   = applyType (ConT effName) (map VarT tvNames)
      memberC = AppT (AppT (ConT ''Member) effTy) (VarT sigName)
      progRes = AppT (AppT (ConT ''Prog) (VarT sigName)) (VarT retTyName)
      opTy    = funType (map (\field -> if field == VarT kName then progRes else field) conFields) progRes
      smartTy = ForallT (map plainTVForall (tvNames ++ [sigName, retTyName]))
                  [memberC] opTy

      namedEffTy   = AppT (AppT (ConT ''WithName) (VarT nameName)) effTy
      namedMemberC = AppT (AppT (ConT ''Member) namedEffTy) (VarT sigName)
      proxyTy      = AppT (ConT ''Proxy) (VarT nameName)
      proxySmartTy = ForallT (map plainTVForall ([nameName] ++ tvNames ++ [sigName, retTyName]))
                       [namedMemberC] (funType [proxyTy] opTy)
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartTy = ForallVisT [plainTV nameName]
                       (ForallT (map plainTVForall (tvNames ++ [sigName, retTyName]))
                         [namedMemberC] opTy)
#endif

  -- Smart constructors
  nName <- newName "n"
  argNames <- forM conFields $ \field ->
    if field == VarT kName
      then newName "a"
      else newName "p"
  let makeFun :: Name -> Type -> Clause -> FunPieces
      makeFun name ty body = FunPieces
        { pPragma = PragmaD (InlineP name Inline FunLike AllPhases)
        , pSig    = SigD name ty
        , pFun    = FunD name [body] }

      opExp  = ConE 'Alg `AppE` (appCon argNames)
      joinExp e = (VarE '(>>=) `AppE` e) `AppE` VarE 'id

      smartDef = Clause (map VarP argNames)
                        (NormalB (VarE 'callJ `AppE` opExp))
                        []
      smart = makeFun smartName smartTy smartDef
      proxySmartDef = Clause (map VarP ([nName] ++ argNames))
                        (NormalB (joinExp ((VarE 'callP `AppE` VarE nName) `AppE` opExp)))
                        []
      proxySmart = makeFun proxySmartName proxySmartTy proxySmartDef
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartDef = Clause (map VarP ([nName] ++ argNames))
                        (NormalB (joinExp ((VarE 'callN `AppE` VarE nName) `AppE` opExp)))
                        []
      namedSmart = makeFun namedSmartName namedSmartTy namedSmartDef
#endif

  -- Pattern synonym
  let patArgs = PrefixPatSyn argNames
      scrut   = VarE 'prj
      inner   = conPCompat 'Just [conPCompat 'Alg
                  [conPCompat conName (map VarP argNames)]]
      pat     = ViewP scrut inner
      builder = NormalB (VarE 'inj `AppE` opExp)
      patDir  = ExplBidir [Clause (map VarP argNames) builder []]
      patDecl = PatSynD patName patArgs patDir pat

  return $ AlgPieces
      { apTySyn      = effTySyn
      , apPat        = patDecl
      , apSmart      = smart
      , apProxySmart = proxySmart
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      , apNamedSmart = namedSmart
#endif
  }

-- | Generate only the /type synonym/ for an algebraic operation.
makeAlgTypeFrom :: Name -> Q [Dec]
makeAlgTypeFrom baseName = do
  AlgPieces{..} <- makeAlgPieces baseName
  pure [apTySyn]

-- | Generate only the /pattern synonym/ (bidirectional) for an algebraic operation.
makeAlgPatternFrom :: Name -> Q [Dec]
makeAlgPatternFrom baseName = do
  AlgPieces{..} <- makeAlgPieces baseName
  pure [apPat]

-- | Generate only the smart constructors (with @INLINE@ and explicit type).
-- for an algebraic operation.
makeAlgSmartFrom :: Name -> Q [Dec]
makeAlgSmartFrom baseName = do
  AlgPieces{..} <- makeAlgPieces baseName
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
  pure (toDecs apSmart ++ toDecs apNamedSmart ++ toDecs apProxySmart)
#else
  pure (toDecs apSmart ++ toDecs apProxySmart)
#endif


--------------------------------------------------------------------------------
-- Scp generators
--------------------------------------------------------------------------------

data ScpPieces = ScpPieces
  { spTySyn  :: Dec
  , spPat    :: Dec
  , spSmart  :: FunPieces
  , spSmartM :: FunPieces
  , spProxySmart :: FunPieces
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
  , spNamedSmart :: FunPieces
#endif
  }

instance ToDecs ScpPieces where
  toDecs (ScpPieces{..}) =
       [spTySyn]
    ++ [spPat]
    ++ toDecs spSmart
    ++ toDecs spSmartM
    ++ toDecs spProxySmart
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
    ++ toDecs spNamedSmart
#endif

makeScpPieces :: Name -> Q ScpPieces
makeScpPieces baseName = do
  info <- reify baseName
  case info of
    TyConI dec -> makeScpPiecesFromDec baseName dec
    _          -> fail "makeScp: expected the name of a data/newtype declaration"

makeScpPiecesFromDec :: Name -> Dec -> Q ScpPieces
makeScpPiecesFromDec baseName dec = do
  (tvbs, con) <- case dec of
    (DataD    [] _ tvbs _ [con] _) -> pure (tvbs, con)
    (NewtypeD [] _ tvbs _  con  _) -> pure (tvbs, con)
    _ -> fail "makeScp: expected data/newtype with a single constructor (without any constraints)"
  case con of
    NormalC _ _ -> pure ()
    RecC _ _    -> pure ()
    _           -> fail "makeScp: only normal constructors or record constructors are supported now."
  when (null tvbs) $ fail "makeScp: the base functor must be at least unary (… k)"
  let conName    = conNameOf con
      conFields  = conArgTys con
      allTvNames = map tvbName tvbs
      (tvNames, kName) = (init allTvNames, last allTvNames)
      appCon :: [Name] -> Exp
      appCon = foldl (\e n -> AppE e (VarE n)) (ConE conName)
      baseStr = nameBase baseName

  when (not (endWithUnderscore baseStr)) $
    fail "makeScp: expected the given datatype to have a name ending with an underscore '_'"

  let effStr  = dropTrailingUnderscore baseStr
      effName = mkName effStr
      patName = effName
      smartName = mkName (lowerHead effStr)
      proxySmartName = mkName (lowerHead effStr ++ "P")
      smartMName = mkName (lowerHead effStr ++ "M")
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartName = mkName (lowerHead effStr ++ "N")
#endif

  -- Type synonym for the operation
  let effTySyn :: Dec
      effTySyn = TySynD effName (map plainTVCompat tvNames)
                   (AppT (ConT ''Scp)
                     (applyType (ConT baseName) (map VarT tvNames)))

  sigName   <- newName "sig"
  nameName  <- newName "name"
  retTyName <- newName "x"
  mName     <- newName "m"

  -- Type signatures for the smart constructors
  let effTy   = applyType (ConT effName) (map VarT tvNames)
      memberC = AppT (AppT (ConT ''Member) effTy) (VarT sigName)
      progRes = AppT (AppT (ConT ''Prog) (VarT sigName)) (VarT retTyName)
      opTy    = funType (map (\field -> if field == VarT kName then progRes else field) conFields) progRes
      smartTy = ForallT (map plainTVForall (tvNames ++ [sigName, retTyName]))
                  [memberC] opTy

      algTy    = (ConT ''Algebra `AppT` VarT sigName) `AppT` VarT mName
      mRes     = AppT (VarT mName) (VarT retTyName)
      opMTy    = funType (algTy : map (\field -> if field == VarT kName
                                                    then mRes
                                                    else field)
                                      conFields)
                   mRes
      smartMTy =  ForallT (map plainTVForall (tvNames ++ [sigName, mName, retTyName]))
                    [memberC] opMTy

      namedEffTy   = AppT (AppT (ConT ''WithName) (VarT nameName)) effTy
      namedMemberC = AppT (AppT (ConT ''Member) namedEffTy) (VarT sigName)
      proxyTy      = AppT (ConT ''Proxy) (VarT nameName)
      proxySmartTy = ForallT (map plainTVForall ([nameName] ++ tvNames ++ [sigName, retTyName]))
                       [namedMemberC] (funType [proxyTy] opTy)
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartTy = ForallVisT [plainTV nameName]
                       (ForallT (map plainTVForall (tvNames ++ [sigName, retTyName]))
                         [namedMemberC] opTy)
#endif

  -- Smart constructors
  nName <- newName "n"
  algName <- newName "alg"
  argNames <- forM conFields $ \field ->
    if field == VarT kName
      then newName "a"
      else newName "p"
  let makeFun :: Name -> Type -> Clause -> FunPieces
      makeFun name ty body = FunPieces
        { pPragma = PragmaD (InlineP name Inline FunLike AllPhases)
        , pSig    = SigD name ty
        , pFun    = FunD name [body] }

      opExp  = ConE 'Scp `AppE` (appCon argNames)

      smartDef = Clause (map VarP argNames)
                        (NormalB (VarE 'call `AppE` opExp))
                        []
      smart = makeFun smartName smartTy smartDef

      proxySmartDef = Clause (map VarP ([nName] ++ argNames))
                        (NormalB ((VarE 'callP `AppE` VarE nName) `AppE` opExp))
                        []
      proxySmart = makeFun proxySmartName proxySmartTy proxySmartDef

      smartMDef = Clause (map VarP (algName : argNames))
                         (NormalB (VarE algName `AppE` (VarE 'inj `AppE` opExp)))
                         []
      smartM    = makeFun smartMName smartMTy smartMDef

#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      namedSmartDef = Clause (map VarP ([nName] ++ argNames))
                        (NormalB ((VarE 'callN `AppE` VarE nName) `AppE` opExp))
                        []
      namedSmart = makeFun namedSmartName namedSmartTy namedSmartDef
#endif


  -- Pattern synonym
  let patArgs = PrefixPatSyn argNames
      scrut   = VarE 'prj
      inner   = conPCompat 'Just [conPCompat 'Scp
                  [conPCompat conName (map VarP argNames)]]
      pat     = ViewP scrut inner
      builder = NormalB (VarE 'inj `AppE` opExp)
      patDir  = ExplBidir [Clause (map VarP argNames) builder []]
      patDecl = PatSynD patName patArgs patDir pat

  return $ ScpPieces
      { spTySyn      = effTySyn
      , spPat        = patDecl
      , spSmart      = smart
      , spProxySmart = proxySmart
      , spSmartM     = smartM
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
      , spNamedSmart = namedSmart
#endif
  }

-- | Generate the full Scp-style bundle from a scoped base functor @T_@.
--
-- Input must be a single-constructor @data@/@newtype@ with at least one
-- type variables, like @data T_ ... k = T_ ...@. Each field of the only
-- constructor must be either @k@ or a type not containing @k@.
--
-- For example, suppose @data T_ s k = T_ s k k deriving Functor@.
-- Then @makeScpFrom ''T_@ produces:
--
--   * @type T s = Scp (T_ s)@
--   * a bidirectional @pattern T@
--   * smart constructors:
--       - @t  :: Member (T s) sig => s -> Prog sig a -> Prog sig a -> Prog sig a@
--       - @tM :: (Monad m, Member T sig)
--             => Algebra sig m -> s -> m a -> m a -> m a@
--       - @tP  :: Member (WithName n (T s)) sig => Proxy n -> s -> Prog sig a -> Prog sig a -> Prog sig a@
--       - @tN  :: forall n -> Member (WithName n (T s)) sig => s -> Prog sig a -> Prog sig a -> Prog sig a@

makeScpFrom :: Name -> Q [Dec]
makeScpFrom baseName = fmap toDecs $ makeScpPieces baseName

-- | Generate the full Scp-style bundle from a type signature.
-- The input is given in the same format as `makeAlg`. For example,
-- @
-- $(makeScp [e| catch :: 2 |])
-- @
-- generates the operation @catch :: Member Catch sig => Prog sig x -> Prog sig x -> Prog sig x@ and
-- the underlying signature functors, pattern synonym, other variants of the smart constructor.
makeScp :: Q Exp -> Q [Dec]
makeScp sigQ = do
  (sigName, d) <- makeAlgOrScpSigFunctor sigQ
  pieces <- makeScpPiecesFromDec sigName d
  pure (d : toDecs pieces)

-- | Generate only the Scp-style /type synonym/.
makeScpTypeFrom :: Name -> Q [Dec]
makeScpTypeFrom baseName = do
  ScpPieces{..} <- makeScpPieces baseName
  pure [spTySyn]

-- | Generate only the Scp-style /pattern synonym/ (bidirectional).
makeScpPatternFrom :: Name -> Q [Dec]
makeScpPatternFrom baseName = do
  ScpPieces{..} <- makeScpPieces baseName
  pure [spPat]

-- | Generate only the Scp-style smart constructors (plain + monadic),
-- each with @INLINE@ and explicit types.
makeScpSmartFrom :: Name -> Q [Dec]
makeScpSmartFrom baseName = do
  ScpPieces{..} <- makeScpPieces baseName
  pure (toDecs spSmart
    ++ toDecs spSmartM
#if MIN_VERSION_GLASGOW_HASKELL(9,10,1,0)
    ++ toDecs spNamedSmart
#endif
    ++ toDecs spProxySmart)

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

-- Extract the constructor name
conNameOf :: Con -> Name
conNameOf = \case
  NormalC n _   -> n
  RecC n _      -> n
  InfixC _ n _  -> n
  ForallC _ _ c -> conNameOf c
  GadtC [n] _ _ -> n
  RecGadtC [n] _ _ -> n
  _ -> error "makeAlg: unsupported constructor form"

-- Extract the argument types of a constructor
conArgTys :: Con -> [Type]
conArgTys = \case
  NormalC _ bs      -> map snd bs
  RecC _ bs         -> [ t | (_,_,t) <- bs ]
  InfixC a _ b      -> [snd a, snd b]
  ForallC _ _ c     -> conArgTys c
  GadtC _ bs _      -> map snd bs
  RecGadtC _ bs _   -> [ t | (_,_,t) <- bs ]

-- Apply a type to many type arguments
applyType :: Type -> [Type] -> Type
applyType = foldl AppT

-- Apply an expression to many expression arguments
applyExp :: Exp -> [Exp] -> Exp
applyExp = foldl AppE

-- Lowercase the first character of a name
lowerHead :: String -> String
lowerHead []     = []
lowerHead (c:cs) = toLower c : cs

-- Uppercase the first character of a name
upperHead :: String -> String
upperHead []     = []
upperHead (c:cs) = toUpper c : cs

-- TyVarBndr name extraction across TH versions
#if MIN_VERSION_template_haskell(2,17,0)
tvbName :: TyVarBndr flag -> Name
tvbName (PlainTV n _)    = n
tvbName (KindedTV n _ _) = n
#else
tvbName :: TyVarBndr -> Name
tvbName (PlainTV n)      = n
tvbName (KindedTV n _)   = n
#endif

eqNameBase :: Name -> Name -> Bool
eqNameBase a b = nameBase a == nameBase b

stripT :: Type -> Type
stripT = \case
  ParensT t     -> stripT t
  SigT t _      -> stripT t
  ForallT _ _ t -> stripT t
  t             -> t

viewArrow :: Type -> Maybe (Type, Type)
viewArrow t = case stripT t of
  AppT (AppT ArrowT a) b -> Just (a, b)
  InfixT a n b | n == ''(->) -> Just (a, b)
  UInfixT a n b | n == ''(->) -> Just (a, b)
  _ -> Nothing

funType :: [Type] -> Type -> Type
funType args res = foldr (\a b -> AppT (AppT ArrowT a) b) res args

-- Drop trailing underscore in a base functor name (e.g. Put_ -> Put)
dropTrailingUnderscore :: String -> String
dropTrailingUnderscore sxx = case reverse sxx of
  ('_':xs) -> reverse xs
  _        -> sxx

endWithUnderscore :: String -> Bool
endWithUnderscore "" = False
endWithUnderscore s = last s == '_'

#if MIN_VERSION_template_haskell(2,21,0)
plainTVCompat :: Name -> TyVarBndr BndrVis
plainTVCompat n = PlainTV n BndrReq

plainTVForall :: Name -> TyVarBndr Specificity
plainTVForall n = PlainTV n SpecifiedSpec
#elif MIN_VERSION_template_haskell(2,18,0)
plainTVCompat :: Name -> TyVarBndr ()
plainTVCompat n = PlainTV n ()

plainTVForall :: Name -> TyVarBndr Specificity
plainTVForall n = PlainTV n SpecifiedSpec
#elif MIN_VERSION_template_haskell(2,17,0)
plainTVCompat :: Name -> TyVarBndr Specificity
plainTVCompat n = PlainTV n SpecifiedSpec

plainTVForall :: Name -> TyVarBndr Specificity
plainTVForall n = PlainTV n SpecifiedSpec
#else
plainTVCompat :: Name -> TyVarBndr
plainTVCompat n = PlainTV n

plainTVForall :: Name -> TyVarBndr
plainTVForall n = PlainTV n
#endif

#if MIN_VERSION_template_haskell(2,17,0)
tyVarName :: TyVarBndr a -> Name
tyVarName (PlainTV n _)    = n
tyVarName (KindedTV n _ _) = n
#else
tyVarName :: TyVarBndr -> Name
tyVarName (PlainTV n)    = n
tyVarName (KindedTV n _) = n
#endif

#if MIN_VERSION_template_haskell(2,18,0)
conPCompat :: Name -> [Pat] -> Pat
conPCompat n ps = ConP n [] ps
#else
conPCompat :: Name -> [Pat] -> Pat
conPCompat n ps = ConP n ps
#endif

splitArrs :: Type -> ([Type], Type)
splitArrs ((ArrowT `AppT` a) `AppT` b) = let (as, r) = splitArrs b in (a:as, r)
splitArrs r = ([], r)

substT :: [(Name, Type)] -> Type -> Type
substT env = \case
  VarT n -> case find (\(n0, _) -> nameBase n0 == nameBase n) env of
              Just (_, ty) -> ty
              Nothing      -> VarT n
  AppT a b -> AppT (substT env a) (substT env b)
  SigT t k -> SigT (substT env t) k
  ForallT bndrs ctx t ->
    let dropShadow acc tv = filter (\(n0,_) -> nameBase n0 /= nameBase (tvbName tv)) acc
        env' = foldl dropShadow env bndrs
    in ForallT bndrs (map (substT env) ctx) (substT env' t)
  InfixT a n b -> InfixT (substT env a) n (substT env b)
  UInfixT a n b -> UInfixT (substT env a) n (substT env b)
  ParensT t -> ParensT (substT env t)
  t -> t
